pipeline {
  agent any

  options {
    skipDefaultCheckout(true)
    timestamps()
  }

  environment {
    REGISTRY      = "samarthbagalkoti"
    IMAGE_NAME    = "mlops-w5-serve"
    AWS_REGION    = "us-east-1"
    EKS_CLUSTER   = "mlops-eks"
    K8S_NAMESPACE = "mlops-w5"

    // Computed later
    // TAG
    // IMAGE
  }

  stages {

    stage('Checkout') {
      steps {
        deleteDir()
        // Uses the job's SCM (you already set URL=github repo, branch=main, script path=W5-D4-Jenkins/Jenkinsfile)
        checkout scm
      }
    }

    stage('Init Vars') {
      steps {
        script {
          env.TAG   = "${env.BUILD_NUMBER}"
          env.IMAGE = "${env.REGISTRY}/${env.IMAGE_NAME}:${env.TAG}"
        }
        echo "IMAGE => ${env.IMAGE}"
      }
    }

    stage('Bootstrap Tools') {
      steps {
        sh '''
          set -eux
          command -v python3 >/dev/null 2>&1 || (apt-get update && apt-get install -y python3 python3-venv python3-pip)
          command -v kubectl  >/dev/null 2>&1 || (curl -sL https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl -o /usr/local/bin/kubectl && chmod +x /usr/local/bin/kubectl)
          command -v aws      >/dev/null 2>&1 || (curl -sL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip" && unzip -q /tmp/awscliv2.zip -d /tmp && /tmp/aws/install)
          command -v envsubst >/dev/null 2>&1 || (apt-get update && apt-get install -y gettext-base)
          command -v docker   >/dev/null 2>&1 || (apt-get update && apt-get install -y docker.io || true)
          docker version >/dev/null
        '''
      }
    }

    stage('Setup Python & Run Training') {
      steps {
        dir('W5-D4-Jenkins') {
          sh '''
            set -eux
            python3 -m venv .venv
            . .venv/bin/activate
            pip install -U pip
            pip install -r requirements.txt
            python train.py
            pytest -v
          '''
        }
      }
    }

    stage('Build Docker Image') {
      steps {
        dir('W5-D4-Jenkins') {
          sh '''
            set -eux
            docker build -f serve/Dockerfile.serve -t "$IMAGE" serve
            docker tag "$IMAGE" "$REGISTRY/$IMAGE_NAME:latest"
          '''
        }
      }
    }

    stage('Push Docker Image') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh '''
            set -eux
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
            docker push "$IMAGE"
            docker push "$REGISTRY/$IMAGE_NAME:latest"
          '''
        }
      }
    }

    stage('Deploy to EKS') {
      steps {
         withCredentials([usernamePassword(credentialsId: 'aws-creds', usernameVariable: 'AWS_ACCESS_KEY_ID', passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
      dir('W5-D4-Jenkins') {
         sh '''
           set -eux
           export AWS_DEFAULT_REGION="$AWS_REGION"
           aws eks --region "$AWS_REGION" update-kubeconfig --name "$EKS_CLUSTER"

           kubectl config current-context
           env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl get ns "$K8S_NAMESPACE" >/dev/null 2>&1 || \
           env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl create ns "$K8S_NAMESPACE"

           IMAGE="$IMAGE" K8S_NAMESPACE="$K8S_NAMESPACE" envsubst < k8s/deployment.yaml.tpl > out-deploy.yaml
           env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl -n "$K8S_NAMESPACE" apply -f out-deploy.yaml
           env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl -n "$K8S_NAMESPACE" apply -f k8s/service.yaml
           env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl -n "$K8S_NAMESPACE" apply -f k8s/hpa.yaml || true
         '''
       }
     }
   }
 }

  post {
    always {
      // Guard kubectl from any proxy env and don't fail the build if it can't reach cluster
      sh 'env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY kubectl -n "$K8S_NAMESPACE" get all || true'
    }
  }
}

